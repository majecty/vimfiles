#!/usr/bin/ruby
# vim:ts=2:sts=2:sw=2

require 'fileutils'
require 'open-uri'
require 'tempfile'
require 'zlib'
require 'rubygems'
require 'zip/zipfilesystem'
require 'archive/tar/minitar'

include Archive::Tar

w_dir = File.expand_path(File.dirname(__FILE__))
bundles_dir = File.join(w_dir, '../bundle')
patches_dir = File.join(w_dir, '../patches')
config = IO.readlines(File.join(w_dir, '../plugins.idnt')).collect do |line|
  plugin = {}
  # GENERAL FORMAT IS:
  #   src =>> name|type
  #   src may be some URI ending in .git -> clone git repository
  #           or # followed by a script ID followed by the type of the downloaded file
  #           or some URI with deducible file type
  #   name is the name of the plugin and will be used as the name of the bundle directory
  #   |type is optional and only useful for download of single .vim files
  #         it is the directory the file belongs in (f.ex. ftplugin for ~/.vim/ftplugin)
  #
  # SOME EXAMPLES:
  #   #1234.zip =>> yankring
  #   #152.vim  =>> showmarks|plugin
  #   http://github.com/scrooloose/nerdtree.git =>> nerdtree

  if line =~ /\s*(\S+)\s*=>>\s*(\S+)/
    src = $1
    dst = $2
    if src =~ /\.git$/ # git repositories
      plugin[:repo] = src
    elsif src =~ /^#(\d+)\.(\S+)/ # vim.org/scripts
      plugin[:id] = $1
      plugin[:file_type] = $2
    elsif src =~ /^(http:\/\/\S+(\/\S+)+\/[^.]+(?:\.\d+)*)\.(\S+)/
      plugin[:url] = "#{$1}.#{$3}"
      plugin[:file_type] = $3
    else
      return nil
    end

    dst =~ /([^|]+)(\|\S+)?/
    plugin[:name] = $1
    if $2
      plugin[:type] = $2.reverse.chop.reverse # strip '|'
    end

    # only return valid entries
    plugin if plugin.has_key?(:id) or plugin.has_key?(:url) or plugin.has_key?(:repo) else nil
  end
end.compact

pathogen_f_path = File.join(w_dir, '../autoload/pathogen.vim')
unless File.size?(pathogen_f_path)
  FileUtils.mkdir_p(File.dirname(pathogen_f_path))
  File.open(pathogen_f_path, 'w') {|f| f << open('http://github.com/tpope/vim-pathogen/raw/master/autoload/pathogen.vim').read}
end

FileUtils.mkdir_p(bundles_dir) unless File.exist?(bundles_dir)
FileUtils.cd(bundles_dir)

config.each do |plugin|
  name = plugin[:name]
  if File.exist?(name) and File.mtime(name) > (Time.now - 60*60*24)
    next
  end
  FileUtils.rm_rf name

  if plugin.has_key?(:repo)
    puts "  Cloning #{name}"
    `git clone #{plugin[:repo]} #{name}`
    FileUtils.rm_rf(File.join(name, '.git'))
  else
    puts "  Downloading #{name}"
    if plugin.has_key?(:id)
      src_ids = open("http://www.vim.org/scripts/script.php?script_id=#{plugin[:id]}").read.scan(/src_id=(\d+)/)
      $stdout.write "    looking for src_id"
      if src_ids.empty?
        raise "  could not find download source for script #{name}/#{plugin[:id]}"
      end
      $stdout.write " -> found #{src_ids[0][0]}\n"
      url = "http://www.vim.org/scripts/download_script.php?src_id=#{src_ids[0][0]}"
    elsif plugin.has_key?(:url)
      url = plugin[:url]
    end
    case plugin[:file_type]
    when 'vim'
      f_path = File.join(name, (plugin[:type] or "plugin"), name + '.vim')
      FileUtils.mkdir_p(File.dirname(f_path))
      File.open(f_path, 'w') {|f| f << open(url).read}
    when 'vba', 'vba.gz'
      puts "    unpacking vba file using vim (ignore warnings)"
      FileUtils.mkdir_p(name)
      FileUtils.cd(name)
      f_vba = "temp.#{plugin[:file_type]}"
      File.open(f_vba, 'w') {|f| f << open(url).read}
      `vim -c "set nomore|let g:vimball_home='.'|so %|q" #{f_vba}`
      FileUtils.rm_f f_vba
      FileUtils.rm_f (f_vba.chomp(".gz")) # vim usually saves the file like this
      FileUtils.cd("..")
    when 'tar.gz', 'tgz'
      Minitar.unpack(Zlib::GzipReader.new(open(url)), name)
    when 'zip'
      temp_f = Tempfile.new('vim_plugin')
      temp_f << open(url).read
      temp_f.flush
      Zip::ZipFile.open(temp_f.path) do |zip_f|
        zip_f.each do |entry|
          f_path = File.join(name, entry.name)
          FileUtils.mkdir_p(File.dirname(f_path)) unless File.exist?(File.dirname(f_path))
          zip_f.extract(entry, f_path)
        end
      end
    else
      raise '  Bad file_type: ' + plugin[:file_type]
    end

    Dir.glob(File.join(patches_dir, name + ".*")).each do |f|
      puts "  Patching #{name} with #{File.basename(f)}"
      FileUtils.cd(name)
      strip = if File.basename(f) =~ /\.(\d+)(\.|$)/ then $1 else 0 end
      system("patch", "-p#{strip}", "-i", f) or raise "    patch failed!"
      FileUtils.cd("..")
    end

    FileUtils.cd(name)
    dirs = Dir.glob("./*").select { |n| File.directory?(n) }
    common_dirs =  dirs.select do |x|
      ["autoload", "syntax", "plugin", "ftplugin", "colors", "after"].include?(x.downcase)
    end
    if common_dirs.empty? and not dirs.empty? then
      if dirs.one? then
        puts "    moving files out of single directory #{dirs[0]}"
        FileUtils.mv(Dir.glob(File.join(dirs[0], "*")), '.')
        FileUtils.rmdir(dirs[0])
      end
    end
    FileUtils.cd("..")
  end
end
